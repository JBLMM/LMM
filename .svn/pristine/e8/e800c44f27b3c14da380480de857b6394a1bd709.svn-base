//#pragma once
//
//#include <boost/shared_ptr.hpp>
//
//#include <LMM/helper/Name.h>
//#include <LMM/instrument/VanillaSwaption.h>
//
//
//class BermudanSwaption
//{
//private:
//	VanillaSwaption vanillaSwaption_;              // The underlying swap, indexStart is the payment date.
//	std::vector<LMM::Index> callableDatesIndex_;   // Suppose it's coincide with vanillaSwaption_'s floatingPaymentDatesIndex
//	
//public:
//
//	BermudanSwaption(const VanillaSwaption& vanillaSwaption, const std::vector<LMM::Index>& callableDatesIndex);
//
//	//double get_strike() const {return vanillaSwap_.get_strike();}
//	//void   set_strike(double strike) {vanillaSwap_.set_strike(strike);}   
//	//double& get_strikeRef() {return vanillaSwap_.get_strikeRef();} // YY ask chi-tan, to don't use this function ...
//
//	//LMM::Index         get_indexMaturity() const {return vanillaSwap_.get_indexStart();}	
//	//const VanillaSwap& getUnderlyingSwap() const {return vanillaSwap_;}
//	//VanillaSwap& getUnderlyingSwap_RefNonConst() {return vanillaSwap_;}  // for skew calculation: need to bump strike ...
//
//	//double payoff(const double& pvVloatingLeg, const double& pvFixedLeg) const;	
//	//Tenor  get_lmmTenorStructureTenorType() const {return getUnderlyingSwap().get_lmmTenorStructureTenorType();} // to compare with the pricer's lmm's strucutreTenor.
//
//};
//
//typedef boost::shared_ptr<BermudanSwaption> BermudanSwaption_PTR;
//
//
